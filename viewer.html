<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Viewer</title>
    
    <!-- CSS Files -->
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/toolbar.css">
    <link rel="stylesheet" href="styles/properties.css">
    <link rel="stylesheet" href="styles/minimap.css">
    <link rel="stylesheet" href="styles/contextMenu.css">
    <link rel="stylesheet" href="styles/filter.css">
    <link rel="stylesheet" href="styles/mobile.css">
    <link rel="stylesheet" href="styles/workflow.css">
    
    <style>
		/* Ensure full viewport */
		html, body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}
		/* Transparent background */
        body {
            background: transparent !important;
        }
        
        .canvas-container,
        #canvas {
            background: transparent !important;
        }

		.viewer-mode .canvas-container {
            position: fixed !important;
            left: 0 !important;
            right: 0 !important;
            top: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: transparent !important;
        }

		.viewer-mode #canvas {
			width: 100% !important;
			height: 100% !important;
			display: block;
		}
        /* Hide editing controls for viewer mode */
        .viewer-mode .left-sidebar,
        .viewer-mode .right-sidebar,
        .viewer-mode .toolbar,
        .viewer-mode .status-bar,
        .viewer-mode #context-menu {
            display: none !important;
        }
        
        .viewer-mode .canvas-container {
            left: 0 !important;
            right: 0 !important;
            top: 0 !important;
            bottom: 0 !important;
        }
        
        /* Show a simple title bar */
        .viewer-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body class="viewer-mode">
    <!-- Title overlay -->
    <div class="viewer-title" id="graph-title">Loading Graph...</div>

    <!-- Canvas Container -->
    <div class="canvas-container" id="canvas-container">
        <svg id="canvas"></svg>
    </div>

    <!-- Minimap -->
    <div id="minimap" class="minimap hidden">
        <div class="minimap-header">
            <span>Minimap</span>
            <button class="minimap-close">âœ•</button>
        </div>
        <svg id="minimap-svg"></svg>
        <div class="minimap-viewport"></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
    </div>

<!-- Graph will be loaded dynamically from URL parameter -->
<script id="embedded-graph-data" type="application/json">
{
  "graph": {
    "metadata": {
      "name": "loading",
      "title": "Loading...",
      "description": "Graph is being loaded"
    },
    "settings": {
      "nodeLabelSize": 12,
      "edgeLabelSize": 10
    },
    "nodes": [],
    "edges": []
  }
}
</script>

    <!-- D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Application Scripts -->
    <script src="js/utils.js"></script>
    <script src="js/graph.js"></script>
    <script src="js/renderer.js"></script>
    <script src="js/minimap.js"></script>

 <script>
    // Set viewer mode flag globally
    window.VIEWER_MODE = true;
    
    // Parse URL parameter
    function getGraphNameFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('graph');
    }
	
	// Get text color from URL parameter
	function getTextColorFromURL() {
		const urlParams = new URLSearchParams(window.location.search);
		return urlParams.get('textColor') || 'black'; // default to black
	}

	// Apply text color dynamically
	function applyTextColor(color) {
		const style = document.createElement('style');
		style.textContent = `
			.canvas-container text,
			#canvas text,
			.node-label,
			.edge-label,
			svg text {
				fill: ${color} !important;
			}
			.viewer-title {
				color: ${color} !important;
			}
		`;
		document.head.appendChild(style);
	}
	
	// Get boundary settings from URL parameter
function getBoundaryFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const boundary = urlParams.get('boundary');
    
    if (!boundary) return null;
    
    // Support formats: "true", "1200x800", "1200,800"
    if (boundary === 'true' || boundary === '1') {
        return { width: 1000, height: 600 }; // default size
    }
    
    // Parse custom dimensions
    const match = boundary.match(/(\d+)[x,](\d+)/);
    if (match) {
        return { width: parseInt(match[1]), height: parseInt(match[2]) };
    }
    
    return null;
}

// Apply boundary box
function applyBoundary(renderer, boundaryConfig) {
    if (!boundaryConfig) return;
    
    const canvas = d3.select('#canvas');
    const containerWidth = document.getElementById('canvas-container').clientWidth;
    const containerHeight = document.getElementById('canvas-container').clientHeight;
    
    // Calculate centered position
    const x = (containerWidth - boundaryConfig.width) / 2;
    const y = (containerHeight - boundaryConfig.height) / 2;
    
    // Draw boundary box
    canvas.append('rect')
        .attr('class', 'boundary-box')
        .attr('x', x)
        .attr('y', y)
        .attr('width', boundaryConfig.width)
        .attr('height', boundaryConfig.height)
        .attr('fill', 'none')
        .attr('stroke', 'rgba(255, 255, 255, 0.3)')
        .attr('stroke-width', 2)
        .attr('stroke-dasharray', '5,5')
        .attr('rx', 10)
        .attr('ry', 10);
    
    // Constrain nodes to boundary
    if (renderer && renderer.simulation) {
        renderer.simulation.on('tick', function() {
            renderer.graph.nodes.forEach(node => {
                if (node.x < x + 30) node.x = x + 30;
                if (node.x > x + boundaryConfig.width - 30) node.x = x + boundaryConfig.width - 30;
                if (node.y < y + 30) node.y = y + 30;
                if (node.y > y + boundaryConfig.height - 30) node.y = y + boundaryConfig.height - 30;
            });
        });
    }
}
    
    // Load graph from file
    async function loadGraphFromFile(graphName) {
        // Add timestamp to prevent caching
        const timestamp = new Date().getTime();
        const response = await fetch(`graphs/${graphName}.json?v=${timestamp}`);
            
            if (!response.ok) {
                throw new Error(`Graph not found: ${graphName}.json (${response.status})`);
            }
            
            const graphData = await response.json();
            
            // Validate graph structure
            if (!graphData.graph || !graphData.graph.nodes) {
                throw new Error('Invalid graph structure');
            }
            
            return graphData;
            
        } catch (error) {
            console.error('Error loading graph:', error);
            throw error;
        }
    }
    
    // Viewer mode initialization
    document.addEventListener('DOMContentLoaded', async function() {
		// Apply text color from URL parameter
		const textColor = getTextColorFromURL();
		applyTextColor(textColor)
        
		const titleEl = document.getElementById('graph-title');
        
        try {
            // Get graph name from URL
            const graphName = getGraphNameFromURL();
            
            if (!graphName) {
                titleEl.textContent = 'No graph specified';
                titleEl.style.backgroundColor = '#e67e22';
                console.error('Usage: viewer.html?graph=filename');
                return;
            }
            
            // Show loading state
            titleEl.textContent = `Loading ${graphName}...`;
            
            // Load graph data from file
            const graphData = await loadGraphFromFile(graphName);
            
            // Update title
            if (graphData.graph.metadata && graphData.graph.metadata.title) {
                titleEl.textContent = graphData.graph.metadata.title;
            } else if (graphData.graph.metadata && graphData.graph.metadata.name) {
                titleEl.textContent = graphData.graph.metadata.name;
            } else {
                titleEl.textContent = graphName;
            }
            
            // Initialize graph
            const graph = new Graph();
            graph.fromJSON(graphData);
            
            // Initialize renderer (viewer mode)
            const canvas = document.getElementById('canvas');
            const renderer = new Renderer(canvas, graph);
            
            // Disable editing in renderer
            renderer.isViewerMode = true;
            
            // Initialize minimap
            const minimapElement = document.getElementById('minimap');
            const minimap = new Minimap(minimapElement, renderer);
            
            // Apply boundary if specified
			const boundaryConfig = getBoundaryFromURL();
			if (boundaryConfig) {
				applyBoundary(renderer, boundaryConfig);
			}

			// Render the graph
			renderer.render();

			// Auto-fit to view after a short delay
			setTimeout(() => {
				if (!boundaryConfig) {
					renderer.fitToView(); // Only auto-fit if no boundary
				}
                // Hide title after a few seconds
                setTimeout(() => {
                    titleEl.style.opacity = '0';
                    titleEl.style.transition = 'opacity 1s';
                }, 3000);
            }, 500);
            
            // Enable zoom and pan only (no editing)
            console.log('Graph viewer loaded successfully');
            console.log('Graph:', graphName);
            console.log('Nodes:', graph.nodes.length, 'Edges:', graph.edges.length);
            
        } catch (error) {
            console.error('Error loading graph:', error);
            titleEl.textContent = `Error: ${error.message}`;
            titleEl.style.backgroundColor = '#e74c3c';
            titleEl.style.opacity = '1';
        }
    });
</script>
</body>
</html>
